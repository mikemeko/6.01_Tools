% Chapter for alternative methods to solving the problem.

\chapter{Methods}
\label{ch:methods}

In this chapter, we discuss our solution to the problem stated in Chapter
\ref{ch:intro}, as well as various alternatives we considered along the way.
First, we briefly introduce the schematic entry GUI.
Next, we discuss in detail how we solved the protoboard layout problem and how
we evaluated our solution.

\section{GUI}

We designed the schematic entry GUI to have a rich set of features so as to make
drawing schematics an easy and intuitive task for students.
Figure \ref{fig:gui_example} gives a version of the schematic shown in Figure
\ref{fig:schematic} as drawn of the schematic entry tool. Appendix \ref{app:gui}
discusses the features and capabilities of the schematic entry GUI in
further detail.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{Images/gui_example.png}
\caption{Sample schematic drawn on the schematic entry tool.}
\label{fig:gui_example}
\end{center}
\end{figure}

\section{Solving the Layout Problem}

In broad terms, we solved the layout problem by formulating it as a search
problem. Given a schematic of a circuit, we start from an empty
protoboard, and search through the space of all possible protoboard layouts to
find a protoboard layout corresponding to the schematic at hand. Importantly, we
utilize various simplifications and heuristics to prune out many states in the
search space.

We broke down the problem into two parts. The first task is finding a placement
of all the circuit pieces on the protoboard. The second task is wiring them up
appropriately.

\subsection{Part 1: Placement}
\label{sec:placement}

Let us first consider how to place a set of circuit pieces on the protoboard for
a given circuit schematic. Any given circuit may contain resistors, op-amps,
pots, motors, head connector parts, or robot connector parts. For each of these
components, we must put down a corresponding piece on the protoboard. As each
piece may be placed on the protoboard in one of many different ways, we first
decided on a fixed set of allowed placements for each of the pieces. Figure
\ref{fig:piece_placement} presents these acceptable placements.
Resistors are placed in the middle strip of the protoboard.
Pots have two possible vertical positions as well as two possible orientations.
The connector pieces have two possible vertical positions each.
Op-amp pieces are also placed in the middle strip of the protoboard, but with
two possible orientations. Op-amp pieces are unique in that each op-amp pieces
contains two op-amps within it. Thus, we face the task of packaging the op-amps
in the schematic in the ``best'' possible way, i.e. so as to require as little
work as possible when wiring the pieces together. Section
\ref{sec:justify_placement} more precisely discusses the number of possibilities.

\begin{figure}
\begin{center}
\includegraphics[width=\linewidth]{Images/piece_placement_options.png}
\caption{Various acceptable ways of putting each of the circuit pieces on the
protoboard.}
\label{fig:piece_placement}
\end{center}
\end{figure}

There are many available options when choosing a placement of a set of circuit
pieces on the protoboard.
First we must choose among a possibly large number of ways
to package together the op-amps in the circuit.
For each possible packaging of
op-amps, we must consider various ways of placing the pieces on the protoboard,
even with the restrictions put forth above.

\subsubsection{Simplifications}

We reduce this large number of possibilities by only allowing placements in
which no
two pieces share a column. This is not necessary in general, but the
number of pieces present in a typical 6.01 circuit could likely be realized
under these circumstances.

Next, we specify that there be exactly two columns on the protoboard separating
each consecutive pair of pieces, unless the pieces are both resistors, in which
case there must be exactly one column separating them. These numbers of columns
were chosen to leave enough space for wiring. Given a set of pieces to be put on
the protoboard, this specification reduces the
problem of choosing a placement for the pieces to finding an \emph{order} of the
pieces together with choosing their respective vertical locations and
orientations. Figure \ref{fig:sample_placements} shows two alternative
placements for the schematic shown in Figure \ref{fig:gui_example} that both
respect the
the stated placement specifications. We consider a few alternatives to finding a
placement under these specifications.

\begin{figure}
\subfigure[Placement 1]{
\includegraphics[width=\linewidth]{Images/sample_placement_1.png}}
\subfigure[Placement 2]{
\includegraphics[width=\linewidth]{Images/sample_placement_2.png}}
\caption{Two possible placements for the schematic shown in Figure
\ref{fig:gui_example}.}
\label{fig:sample_placements}
\end{figure}

\subsubsection{Random Placement}

One simple placement strategy is to choose a placement randomly.
That is, we choose
an op-amp packaging randomly; we choose an order of the pieces randomly; and we
choose the vertical locations and orientations of the pieces randomly as well.
The advantage of this
approach is that it gives us a placement very quickly without requiring much
computation. On the other hand, we may end up placing two pieces that need to be
connected to each other very far apart, which would make the wiring task more
difficult. We ought to consider alternatives in which we take into
account the task of wiring. We should try to place the pieces so as to require
as little work as possible during the wiring step.

\subsubsection{Minimal Heuristic Cost}

The key idea is that if two pieces are meant to be connected together by wires,
then they should be placed close to each other on the protoboard. We can
capture this idea by assigning heuristic costs to the placements and choosing
a placement that produces the minimal heuristic cost. To that end, there are two
heuristic cost functions we considered.

\paragraph{Distance Based Cost}
Given a circuit
schematic and a corresponding placement of the circuit pieces on the protoboard,
every pair of components in the schematic that is connected by a wire gives us
a corresponding pair of
locations on the protoboard that must be connected by wires. However, we can
express this requirement a little bit more concisely. We must consider all
of the nodes in the schematic, and find the circuit components in the schematic
that are connected to the respective nodes. Now for each node in the circuit, we
get a set of locations on the protoboard that must be interconnected. The
first step in devising the distance based cost function is to have a way to
estimate the cost of connecting two locations on the protoboard. A simple such
cost function is the Manhattan distance between the two
locations. Since we want to produce layouts that only contain
horizontal and vertical wires (i.e. no diagonal wires), the Manhattan distance
cost is appropriate. Given this heuristic cost for connecting two locations with
wires, we can define the cost for interconnecting the locations
associated with a particular node to be the weight of the minimum spanning tree
of the locations. Now we can define the cost of a placement to be the sum over
all nodes in the circuit of the cost for interconnecting the locations for each
node.

We can demonstrate this cost function using the two placements shown in Figure
\ref{fig:placement_costs}. In the Figure, each placement has two connections
that must be made, the first indicated by two circled locations and the second
indicated by two locations outlined by rectangles. The distance based cost for
Placement 1 is $(3) + (2 + 3) = 8$ while the distance based cost for Placement 2
is $(7) + (2 + 3) = 12$. As desired, the cost function indicates that Placement 1
is the better of the two.

\begin{figure}[H]
\centering
\subfigure[Placement 1]{
\fbox{\includegraphics[width=4.5cm]{Images/placement_example_1.png}}}
\subfigure[Placement 2]{
\fbox{\includegraphics[width=4.5cm]{Images/placement_example_2.png}}}
\caption{Placements to demonstrate cost functions.}
\label{fig:placement_costs}
\end{figure}

\paragraph{Blocking Based Cost}
The most scarce resource on the protoboard are the rows. There are $10$ rows
with which to work, and in producing a layout, we must fit all the wires within
these $10$ rows. This gives us an idea on how to define how hard a placement
will be to wire. Given a set of pieces, we can find a set of pairs of locations
on the board that need to be connected as we did above.
As noted in Section \ref{sec:what_is_protoboard} there are two groups of $5$
rows on a protoboard. For each group of rows and each column in the group of
rows, we can count how many pieces reside in that column, and how many wires may
pass through the column (in connecting a given pair of locations assuming an
empty protoboard). The heuristic should reflect columns that
would be used heavily. In our implementation, the final cost is computed as
the sum of the squares of the counts for each column.

To demonstrate this cost function, let us look at the two placements in Figure
\ref{fig:placement_costs} once again. Each column in the placements is labeled
with the cost associated with the column in the manner described above. The cost
for Placement 1 is the sum of the squares of the costs for each column, which
evaluates to $65$. The cost for Placement 2, computed similarly, is $87$. Once
again, this cost function indicates that Placement 1 is better.

\subsubsection{Small Heuristic Cost}

Using one of the two cost functions discussed above, we can aim to find a
placement with the minimal cost. However, this involves trying all possible
orderings of the pieces with which we are working. For example, if we are trying
to order $10$ pieces, we would need to look at $10! = 3628800$ possible
orderings. Note that this is in addition to
searching over all possible ways
of packaging the op-amps together. It is clear to see that the search for a
minimal cost placement quickly gets out of hand.
Rather than looking for an optimal placement, we aim for a placement with small
cost.

Algorithm \ref{alg:small_cost_placement} presents a polynomial-time procedure
that orders a
given list of pieces in a way that results in a small cost. The algorithm places
one of the pieces at a time, starting from an empty placement. It relies
on two ideas. First, once a piece has been placed, all the pieces that are
connected to it will be placed soon after so that it is more likely that those
pieces are placed close to it. Second, we place the pieces with the most nodes
first since those are the ones that most likely have connections with many other
pieces.

\begin{algorithm}
\KwData{A list $P$ of circuit pieces.}
\KwResult{A list $R$ of circuit pieces representing a placement.}
\BlankLine
Sort $P$ in decreasing number of nodes on the respective pieces\\
$Q$ $\leftarrow$ empty Queue\\
$R$ $\leftarrow$ empty List\\
\While{$P$ is not empty}{
Pop the first piece in $P$ and push it onto $Q$\\
\While{$Q$ is not empty}{
$p$ $\leftarrow$ $Q$.pop()\\
Consider all vertical locations and orientations of $p$\\
Place $p$ at an index in $R$ that minimizes the cost of $P$\\
\ForEach{piece $q$ in $P$ connected to $p$}{
Pop $q$ out of $P$ and push it onto $Q$\\
}}}
\caption{Producing a circuit piece placement with small heuristic cost.}
\label{alg:small_cost_placement}
\end{algorithm}

\subsection{Part 2: Wiring}

Once the placement task is done, the next problem is wiring.
We approach this problem as a search problem and use the $A*$ search algorithm to
solve it. In fact, the wiring step uses an infrastructure for the $A*$ search
algorithm exactly as presented in 6.01. Hence, students in
the class may appreciate an application of something they learned
earlier in the course to produce a tool that they are using for something that
may seem completely unrelated and difficult.

\subsubsection{Using $A*$}

The $A*$ algorithm can be used to search for a path from some starting
vertex\footnote{The preferred terminology is ``a node in a graph'' but here we
will use the term ``vertex'' since we already use ``node'' to refer to nodes in
circuits.} in
a graph to some goal vertex \footnote{In fact, $A*$ guarantees an optimal path, a
path that has the minimum possible cost from the starting vertex to a goal
vertex, if we use a heuristic that is \emph{admissible}. A heuristic is said to
be admissible if it does not overestimate the actual minimal cost to a goal
vertex
for any state. Here, however, we will not worry about the admissibility of our
heuristic as our main goal is designing the heuristic to prune as many states as
possible.}. The algorithm works by keeping track of an agenda
of vertices to consider
in a priority queue, where the value associated with each vertex in the priority
queue is the sum of the cost to get from the start vertex to the vertex at hand
and the value of the heuristic
computed at the state of the vertex, which is an estimate of the minimum
cost to get from the vertex at hand to a goal vertex.
At each step, the algorithm pops
one vertex from the priority queue (the vertex with the minimum associated
value). If the vertex happens to satisfy the goal of
the search, the algorithm returns the state for that vertex as the answer to
the search
problem. Otherwise, it adds the children vertices of that vertex to the priority
queue and continues. When adding children vertices, the algorithm takes care not
to reconsider
states that it has already considered via a different path. We call the process
of popping a vertex from the priority queue and treating it as described
\emph{expanding} the vertex.
In general, when using the $A*$ algorithm, we need to design four things:

\begin{enumerate}
\item The notion of a vertex in the
search tree, the cost associated with a vertex, and how we obtain the neighbors
of a vertex,
\item The starting vertex,
\item How we identify whether a particular vertex in the search tree achieves
the goal of the search, and
\item A heuristic function that estimates the distance from a given vertex to a
goal vertex.
\end{enumerate}

\subsubsection{Vertices}

Each graph vertex will represent a protoboard layout and a set of locations on
the protoboard that have yet to be connected by wires. The starting vertex will
represent a protoboard layout that just has the circuit pieces with no
wires as well as all the pairs of locations that must be connected.

We obtain the neighbors of a vertex by taking the current protoboard layout and
producing new ones in which we place exactly one wire at various locations. We
choose the starting point of a wire to be any one of the free locations on the
protoboard that is already connected to one of the pieces, and we extend the
wires in all possible vertical and horizontal directions up to some fixed wire
length. Note that we need
to take great care when placing wires in order not to short, or directly connect,
two different nodes. We
discard any vertices that arise from placing a wire that shorts two different
nodes.

The way we define the cost of a vertex, i.e. the cost of getting from the
starting vertex to a vertex of interest, depends on our definition of a good
protoboard layout. In general, we want to penalize having
long wires, many wires, or crossing wires. In our implementation, while we have
a large penalty for two crossing wires of opposite orientations (i.e. vertical
and horizontal), we do not allow occlusions as
they are particularly difficult to physically build and debug.
Finally, we want to favor making a desired interconnection between locations
on the protoboard. That is, if placing one wire results in a layout in which
one of the pairs of locations that need to be connected becomes connected, then
the cost of that child vertex should reflect that fact.

An important consideration we need to make is how to organize the
search. Recall that we have a set of nodes in the circuit of interest, and for
each node we have a set of locations that need to be interconnected. Given this
information, we considered the following three strategies to carryout the
search:

\begin{enumerate}
\item All pairs: For each node, collect a set of pairs of locations on the
protoboard
corresponding to a minimum spanning tree of the locations for that node, so that
if all pairs of locations in this spanning tree are connected, then the
locations for the node will be interconnected. Collect all such pairs of
locations for all of the nodes in the circuit, and have the starting vertex
represent
this set of pairs of locations. In this strategy, we run exactly $1$ search to
solve the problem.
\item Per-node, increasing: Treat each node separately. That is, iteratively
connect the locations for each of the nodes until there are no more disconnected
nodes in the circuit. In this strategy, we run a number of searches equal to the
number of nodes in the circuit to solve the problem. Order the searches in
\emph{increasing} order of the number of locations per node, breaking ties
arbitrarily.
\item Per-node, decreasing: Similar to per-node, increasing, but here order the
searches in \emph{decreasing} order of the number of locations per node.
\item Per-pair, increasing: Treat each pair of locations that needs to be
connected separately. That is, iteratively connect pairs of locations that need
to be connected until there are no more disconnected pairs.
In this strategy, we run a number of searches equal to the number of pairs of
locations that must be connected. Order the searches in \emph{increasing} order
of the Manhattan distance between the pairs of locations, breaking ties
arbitrarily.
\item Per-pair, decreasing: Similar to per-pair, increasing, but here order the
searches in \emph{decreasing} order of Manhattan distance between the pairs of
locations.
\end{enumerate}

When using one of the latter two choices presented above, since we will
generally have to do multiple searches, it will be important to decide on the
order in which we run the searches. For each strategy, we considered one of
two choices. In per-node wiring, we may consider the nodes either in
\emph{increasing} or \emph{decreasing} order of number of locations associated
with each node. In per-pair wiring, we may consider the pairs either in
\emph{increasing} or \emph{decreasing} order of Manhattan distance from
each other. Ties are broken arbitrarily in each case.

The choice of one of the three strategies presented above as well as the choice
of order in the latter two strategies has a significant effect on the outcome of
the search. We will look at the difference in detail in Chapter \ref{ch:results}.

\subsubsection{Goal test}

Given a vertex, we know that it is a goal vertex if all of the pairs of
locations it holds are already connected in the protoboard it holds.

\subsubsection{Search heuristic}

In $A*$ search, choosing the right heuristic can often make the search much more
efficient. Given a
vertex, we can estimate its distance from a goal as follows. For each pair of
locations $(loc_1, loc_2)$ that need to be connected, we could consider its
distance from the
goal to be the smallest Manhattan distance between any location connected to
$loc_1$ and any other location connected to $loc_2$. To compute the heuristic
cost of a vertex, we simply add up this value for each of the pairs of locations
that need to be connected. In Chapter \ref{ch:results} we will compare the
performance of $A*$ with this heuristic versus carrying out Best First Search
with this heuristic. In Best First Search, as opposed to in $A*$, vertices are
considered in order of decreasing heuristic value.

\subsubsection{Limiting the number of expanded vertices}

With the implementation of $A*$ we have discussed so far, the algorithm
terminates if we either find a solution, or we
exhaust the search space without finding a solution. In our search problem, the
number of states is very large, so this implementation of $A*$ may sometimes
run out
of memory during the search. To mitigate this problem, we introduce a limit to
the number of vertices the algorithm expands before giving up. That is, if the
algorithm expands a certain fixed number of vertices and still has not found an
answer, the algorithm gives up. For us, this limit is set to $300$ vertices.
In Chapter \ref{ch:results} we provide data to justify this choice.

\subsection{Combining the Methods}
\label{sec:combined_alg}

With the methods discussed so far, we aimed to completely solve the layout problem
with one placement method and one wiring method. However, as we will soon see,
such an algorithm is bound to fail on some set of schematics. When we ultimately
put the final algorithm in front of students, we would like to avoid failure.
The algorithm should be able to generate a layout for any schematic.
Generating a layout
with a few diagonal or crossing wires is better than silently failing and leaving
the student empty handed. Here, we will discuss how we combine the methods
described so far into one layout algorithm. The motivation for this combination
will be discussed in Chapter \ref{ch:discussion} based on the data we obtain
for the alternatives described above. Algorithm \ref{alg:combined} presents the
combined algorithm.

\begin{algorithm}
\KwData{A circuit schematic $C$.}
\KwResult{A layout corresponding to $C$.}
\BlankLine
\ForEach{Placement cost metric $M$ in (DISTANCE, BLOCKING)}{
$P$ $\leftarrow$ Placement for $C$ by using cost metric $M$.\\
Connect the top and bottom rails on $P$.\\
\ForEach{Order $O$ in (INCREASING, DECREASING)}{
$pairs$ $\leftarrow$ Pairs of location on $P$ to connect given schematic $C$ and connection order $O$.\\
\ForEach{$(loc_1, loc_2)$ in $pairs$}{
Attempt to connect $loc_1$ and $loc_2$ on $P$.\\
If successful, update $P$ accordingly and then post-process $P$.\\
If not, record that the pair $(loc_1, loc_2)$ was not successfully connected.\\
}
If all pairs are successfully connected, return $P$.\\
}}
Pick unfinished layout with fewest and most compact disconnected pairs.\\
Connect remaining pairs with shortest possible wires (possibly diagonal).\\
Post-process and return resulting layout.\\
\caption{Layout algorithm obtained by combining multiple ideas.}
\label{alg:combined}
\end{algorithm}

There are a few key items in Algorithm \ref{alg:combined}. The algorithm works
by attempting to solve the problem in four different ways: two different ways of
doing placement together with two different orders of wiring pairs. Note,
therefore, that we have chosen the per-pair wiring scheme discussed above.
If any one of the four trials
succeeds, the algorithm immediately returns the corresponding layout. If all
four trials fail, on the other hand, the algorithm picks one of the four
unfinished layouts that would require comparatively little additional wiring and
completes that solution by placing possibly diagonal wires. This last step makes
it highly unlikely that the algorithm will ever fail.
The only way for the algorithm to fail is for there to be two nodes that need to be
connected where all of the protoboard locations for at least one of the nodes are
occupied, which is highly unlikely. This high success rate comes at the
cost of placing wires that will almost surely cross other wires on the board.

The algorithm automatically starts out by connecting the top and bottom rails
of the protoboard
so that all rail rows are used to connect to power and ground, and no other
nodes. This restriction was not enforced before, but it is a restriction that
certainly makes debugging easier.

The algorithm also has a post-processing step that attempts to to improve the
layout. The post-processing step makes three types of simple changes to the
layout. First, we throw away any superfluous wires that do not serve to connect
two parts of the circuit. Superfluous wires may be added to the layout
in the search done by the wiring step, though very rarely. Second, we truncate
long vertical wires into an equivalent set of smaller wires. For example, a wire
going from one of the top rails to one of the bottom rails can be replaced by
three smaller wires making the same connection. This change frees up rows for
subsequent connections. Finally, if shifting a horizontal wire up or down
results in a layout with fewer crossing wires, we make that change.

The last important aspect of this final algorithm not explicitly stated in
Algorithm \ref{alg:combined} is that the algorithm that will be put
in front of students will only be allowed to use wires of a select few lengths.
The kits that students work with do not come with wires of all lengths,
so we force the wiring step to use wires of only those allowed lengths. We also
avoid using length-$1$ wires as they are very difficult to insert and remove from
and hard to see on the physical protoboards.

\subsection{Evaluation}

Here we present how we evaluated our solution to the layout problem
to test how well it would serve students in 6.01.
We tested the layout tool on numerous schematics and
analyzed its performance on generating layouts from those schematics.
As manually generating
numerous test schematics is tedious and time-consuming, we devised a method
to randomly generate thousands of test schematics. As the tool targets 6.01 labs,
we tried to design the randomly generated schematics so that the range of
complexity of these schematics mimics the range of complexity of circuits that
students may build in 6.01.

The random schematic generation goes as follows. We create $6$ basic parts
of schematics. These $6$ bases are:
\begin{itemize}
\item Three resistors arranged in a T-shaped configuration.
\item Two resistors in series connected to a follower op-amp configuration.
\item A pot connected to a follower op-amp configuration.
\item A motor.
\item A robot head.
\item A robot.
\end{itemize}
These bases are depicted in Figure
\ref{fig:random_gen_bases}. They cover all of the components that may be
necessary in a 6.01 circuit. Each base offers at least $3$ points of
connection with other bases. The random generation algorithm takes all
possible combinations of up to
$6$ bases, allowing for repetition of bases with some restrictions.
The robot head and robot bases can appear at most once as there is
no need for more than one of each of these in 6.01 labs. The pot and follower
op-amp base can appear at most twice as we never need more than two pots in 6.01
circuits. The motor base can also appear at most twice as we never need more
than two motors per circuit in 6.01 labs. The other two bases, T-resistor
configuration and two resistors in series with a follower op-amp, can be
repeated up to 6 times. For a given combination of bases, we generate a
set of schematics in which we randomly choose to make connections between the
bases. Figure \ref{fig:example_random_schematic} presents a sample randomly
generated schematic.

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{Images/auto_generation_bases.png}
\caption{Bases for random schematic generation.}
\label{fig:random_gen_bases}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{Images/auto_generation_example.png}
\caption{Sample randomly generated schematic.}
\label{fig:example_random_schematic}
\end{center}
\end{figure}

This scheme produces a total of $4425$ test schematics out of $1.2\cdot10^{27}$
possibilities\footnote{These numbers were computed computationally as the
variety of choices that could be made in the process makes it difficult to
compute them combinatorially}.
When testing a particular algorithm on these test
schematics, we run the algorithm on each test schematic $10$ times. Chapter
\ref{ch:results} presents the data collected in this manner comparing the
various alternatives discussed in this Chapter.

An important question we must answer is how we quantify the goodness (or badness)
of a particular layout. Our approach takes a weighted sum of a particular set of
attributes of a given layout, where the weights are chosen comparatively. We set
the badness of a layout to be:
\begin{align*}
\centering
&1 \cdot \text{NUMBER\_OF\_WIRES} &+ \\
&2 \cdot \text{TOTAL\_WIRE\_LENGTH} &+ \\
&10 \cdot \text{NUMBER\_OF\_WIRE\_CROSSES} &+ \\
&10 \cdot \text{NUMBER\_OF\_DIAGONAL\_WIRES} &+ \\
&50 \cdot \text{NUMBER\_OF\_WIRE-PIECE\_CROSSINGS} &+ \\
&500 \cdot \text{NUMBER\_OF\_WIRE\_OCCLUSIONS}.
\end{align*}
We will use this metric to decide which of a given set of alternative
layout generation strategies tends to produce better layouts.
The weights in the metric were chosen to reflect how
bad each of the attributes are relative to one another. This choice of weights,
therefore, reflects the following reasonable set of statements. Recall that our
goal is to produce layouts that are easy to build, easy to debug, and
aesthetically pleasing.
\begin{itemize}
\item Having an additional wire is about as bad as increasing the total wire
length on the protoboard by $2$.
\item Having two wires that cross is about as bad as increasing the total
wire length on the protoboard by $5$.
\item A diagonal wire is about as bad as two wires that cross.
\item Having $10$ wires that cross is about as bad as having a wire that
crosses a circuit piece.
\item Having $10$ wires that cross circuit pieces is about as bad as having a
wire occlusion. The penalty on wire occlusions is meant to indicate that we want
absolutely no wire occlusions in our layouts.
\end{itemize}

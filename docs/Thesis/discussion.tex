% Chapter where we explain the results.

\chapter{Discussion}
\label{ch:discussion}

In this section we provide justifications for the choices made in solving the
protoboard layout problem, and also detailed analysis of the data presented in
Chapter \ref{ch:results}.

\section{Search Space Size}

The proposed solution to this problem involves several simplifications and uses
of heuristics. This is a result of the fact that the search space we are working
with is very large. It is difficult to say exactly how large this search space
is, but we can get an idea of its size. Let us just consider the number of ways
we can put wires down on an empty protoboard (even in ways that may not make
sense
from a circuit theory standpoint). Finding this number reduces to finding the
number of ways $T(n)$ in which we can choose pairs out of $n$ items. Equation
\ref{eq:telephone} givens an expression for $T(n)$.

\begin{equation}
T(n) = \sum_{i = 0}^{\lfloor \frac{n}{2} \rfloor}{\frac{n!}{i! (n - 2i)! 2^i}}
\label{eq:telephone}
\end{equation}

In this problem, we have that $n = 830$, the number of available locations on an
empty protoboard. Evaluating $T$ at $n = 830$, we get approximately $2.8e1043$.
The largeness of this number indicates that doing any sort of exhaustive search
will be hopeless.

\section{Justifying Placement Choices}
\label{sec:justify_placement}

\subsubsection{Resistors}

For the sake of simplicity, and to significantly reduce the search space, for
every resistor in the schematic, we use one resistor piece placed in the middle
strip of the protoboard as shown in Figure
\ref{fig:piece_placement}. This choice, i.e. allowing the resistor pieces to
only reside in the middle strip of the protoboard, is critical
as the resistor pieces can generally be placed at numerous places on the
protoboard.
With this restriction, there are $63$ slots available for one resistor. Without
this restriction, there are a total of $763$ slots available. The restriction is
good when we consider the reduction in the search space size. On the other hand,
the restriction is bad when we
consider the size of circuits the algorithm can layout. Given that the number
of resistors in a typical 6.01 circuit is very
small, this restriction proves to be very useful.

\subsubsection{Op-amps}

Op-amps are the trickiest components to handle because each op-amp package put
on the protoboard contains two op-amps within it. Equation
\ref{eq:opamp} presents an expression for the value $f(n)$, the number of
different ways to package together $n$ op-amps. For example, if we have $2$ Op
Amps, we can either use one op-amp package for each, or put them both in the
same package, which we can do in one of two different ways. Hence, $f(2) = 3$.
To get a sense of how many different packagings are possible, Table
\ref{tb:opamp} gives the values of $f(n)$ for various $n$.

\begin{equation}
f(n) = \sum\limits_{k=0}^{\lfloor\frac{n}{2}\rfloor}{\frac{n!}{k!(n - 2k)!}}
\label{eq:opamp}
\end{equation}

\begin{table}
\begin{center}
\begin{singlespace}
\begin{tabular}{c | c}
$n$ & $f(n)$ \\
\hline
\hline
1 & 1 \\
2 & 3 \\
3 & 7 \\
4 & 25 \\
5 & 81 \\
6 & 331 \\
7 & 1303 \\
8 & 5937 \\
9 & 26785 \\
10 & 133651
\end{tabular}
\end{singlespace}
\end{center}
\label{tb:opamp}
\caption{Number of ways of packaging together $n$ op-amps for various values of
$n$.}
\end{table}

Our placement approach explores all possible ways
of packaging up the op-amps. We do this because the typical 6.01 circuit contains
no more than $6$ op-amps, and so we are tasked with exploring at most $331$
alternatives, which doesn't happen to be too computationally intensive. If the
algorithm was meant to handle a larger number of op-amps (for example $10$), then
this approach would be silly, and we would have to resort to perhaps considering
the packagings that require the fewest number of op-amps to make a choice.

\section{Explaining the Results}

Chapter \ref{ch:results} presented quantitative data to compare the various
alternatives we have in solving the protoboard layout problem. Here, we will
analyze that data and give reasonings for why we obtained the results
that we obtained.

\subsection{Comparing Placement Methods}

In Figure \ref{fig:placement_success} and Table \ref{tb:placement_success} we
see that the distance method exceeds the blocking method in number of circuits
solved $10$ times out of $10$ as well as in the number of circuits solved $0$
to $2$ times out of $10$. On the other hand, the blocking method exceeds the
distance method in number of circuits solved from $3$ to $9$ times out
of $10$. Overall, the blocking placement method is slightly more successful
than the distance placement method. Despite this difference, we note that the
two alternatives have very
close success rates. We do note, however, that both methods are significantly
more successful than using a random placement. As a function of circuit
complexity, Figure
\ref{fig:placement_success_trend} suggests that the two alternatives have almost
identical success rates. As we would expect, we certainly observe that as the
complexity of the circuits
increases, success rate generally decreases for both of the placement methods.
Once again, we observe that the distance and blocking based placement methods
are much more successful than random placement, especially as the circuit
complexity increases.
The curves in Figure \ref{fig:placement_success_trend} seem to shoot back up
at the far end of the figure, but this is a result of the fact that there are
very few circuits at that end of the figure, on which the algorithm happened to
be consistently successful.

When we consider wiring time as the basis for comparison, we observe from
Figure \ref{fig:placement_time_trend} that, once again, the two methods are
very similar, with random placement being markedly worse than both.
We see that the distance method generally takes slightly less
wiring time than the blocking method, but the difference between the two is
almost negligible. As we would expect, we certainly see that as the complexity
of the circuits increases, the amount of time spent by the wiring step also
increases. As we did for the success rate trends as a function of circuit
complexity, we observe that there are outliers at the far end of the figure due
to a very small sample of the most complex circuits in the randomly generated
schematic dataset.

Finally, let us look at layout goodness as the basis for comparison. Figure
\ref{fig:placement_quality_trend} presents graphs that compare numbers of wires,
numbers of wire crosses, and total wire lengths.
Figure \ref{fig:placement_badness_trend} shows the trend of layout badness
computed using our metric as a function of circuit complexity.
We first observe that the
number of wires used by the two methods are almost identical. As the complexity
of the circuit increases, we see that the blocking method uses more wires than
does the distance method, but by and large the values are very comparable. When
we look at the number of wire crosses in the layouts, we
see that the blocking method consistently results in more wire crosses. Similarly,
when we look at the total length of wires used in the layouts, the blocking
method exceeds the distance method consistently, with the difference getting
higher as complexity increases. This can be explained by the fact that the
blocking method may require elaborate connections, especially as the circuits
get more complex while the distance method is tuned to require wirings between
pairs of locations that are closer together. Finally, we do see that the random
placement method, per our badness metric, produces much worse layouts than the
other two methods even when it does succeed.

It is difficult to conclusively pick the best placement method from these
results. What we can certainly tell is that the distance based method and the
blocking based method are both significantly better than random placement.

\subsection{Comparing Wiring Methods}

To compare the wiring methods, let us start with the success rate for each method.
Figures \ref{fig:wiring_success} and \ref{fig:wiring_success_trend}, and Table
\ref{tb:wiring_success} provide the appropriate data. The very first fact we
observe is that the all-pairs method has a much smaller success rate than all of
the other alternatives, especially as circuit complexity increases. The reason
for this, in large part, is the fact that we impose a cutoff on the number of
nodes to expand in the search (TODO: this must be discussed in Methods). As we
are using just the one search to connect all pairs of locations, the search
cutoff would be expected to have more of an effect on the all-pairs method. The
other four alternatives have very comparable success rates.

Next we look at Figure \ref{fig:wiring_time_trend} to compare wiring times for
the five methods. Once again, we observe that the all-pairs methods takes
significantly more time than the other methods. When attempting to connect all
pairs in one search, the method searches for an appealing layout, which may
require searching through a large number of alternatives, especially for more
complex circuits. Hence, we would expect the all-pairs methods to generally take
more time than the other alternatives. We also observe from Figure
\ref{fig:wiring_time_trend} that the wiring times for the two per-node methods
are comparable, and that the wiring times for the two per-pair methods are also
comparable, but that the per-node wiring times are generally bigger than the
per-pair wiring times. This trend is also expected as the per-node methods
attempt to connect multiple pairs of locations at once while keeping the layout
pleasing, and this generally requires searching through more alternatives than
connecting each of the pairs of locations individually. It is important to note
that per-node, increasing generally takes more time than per-pair, decreasing,
and also that per-pair, increasing generally takes more time than per-pair,
decreasing.

Finally let us look at Figure \ref{fig:wiring_quality_trend} to compare the
quality of the layouts produced by the five alternative wiring methods. First,
as we observed in the placement method comparison, we see that there is very
little difference in terms of number of wires used and the total wire length.
However, there are significant differences in the number of wire crosses. We see
that the all-pairs method generates layouts with much fewer wire crosses than
the other methods. This is completely expected since we run one search to
connect all pairs of locations while attempting to keep the layout as nice as
possible. Conversely, the per-pair, decreasing and per-node, decreasing methods
result in the most number of wire crosses. It is very interesting to note that
the per-node, decreasing method produces more wire crosses on average than the
per-pair,
increasing method. Here we observe that the order in which we consider pairs of
locations has a telling effect on how good the layouts will be. In essence,
connecting the harder pairs of locations generally produces more wire crosses.

What we have observed is that while the all-pairs method is the least successful
method and the one that generally takes the longest among the five,
it generally produces the best layouts when it does succeed. On the other hand,
the alternatives that break down the problem into smaller pieces succeed more
often and finish more quickly while producing worse results. Furthermore,
the more finely we breakdown the problem, the faster the overall algorithm.
Lastly, ordering subproblems from hardest to easiest has the effect of making the
overall wiring step complete faster but producing worse results than the reverse
order and not necessarily getting a markedly better success rate.

\subsection{Comparing Search Methods}

We now compare our two alternative search algorithms: $A*$ and Best First Search.
Let us start by comparing success rates. Figures \ref{fig:search_success} and
\ref{fig:search_success_trend} and Table \ref{fig:search_success} present the
appropriate data. We clearly observe that Best First Search is much more
successful than $A*$. $98\%$ of the test circuits were solved at least $8$ times
out of $10$ when we used Best First Search, versus $85\%$ when we used $A*$.
This result is not surprising because Best First Search hungrily hunts for
layouts that satisfy the connection requirements without caring for the
aesthetics of the layouts. Hence, Best First Search is much less susceptible to
the $300$ states to expand restriction than $A*$. The fact that the quality of
the results we get from Best First Search are worse
is clearly evident from Figure \ref{fig:search_quality_trend}. Most importantly, the
number of wire crosses in the layouts produced by Best First Search are markedly
greater than the number of wire crosses in the layouts produced by $A*$. We also
observe that the total wire length is greater when using Best First Search. The
fact that Best First Search settles for any layout that satisfies the connection
requirements suggests that it should finish more quickly in addition to being
more successful. Figure \ref{fig:search_time_trend} supports exactly this
expectation.

Our choice of a search algorithm forces us to consider a tread-off between quick
success and quality. If we choose Best First Search, most runs will be successful
and terminate quickly, but will produce very poor results. If we choose $A*$,
not as many runs will be successful, and the successful runs will take longer to
terminate, but we will get much better layouts.

\subsection{Putting Them All Together}
\label{sec:method_combination}

Now we will discuss whey the combination algorithm given in Algorithm
\ref{alg:combined} is structured the way it is, and we will also
discuss the data we obtained for the combined algorithm. Recall that the combined
algorithm makes four attempts at generating a complete layout. We try both
placement methods, the distance method first and the blocking method second. We
try the distance method first because it tends to generate layouts with fewer
crossing wires and smaller total wire length. We use per-pair wiring, and
consider both orders of doing the wiring, increasing order first and decreasing
order second. We use per-pair wiring because it takes considerably
less time than either per-node or all-pair wiring, and neither of the other
wiring methods has a better success rate. We try increasing order first because
that tends to generate layouts with fewer crossing wires then decreasing order.

Let us now consider the data we obtained for the combined algorithm. Firstly, we
saw that the combined algorithm had a $100\%$ success rate, which is critical
when we consider the fact that students will be using a tool that almost never fails.
Next, Figure \ref{fig:final_num_trials} presents very encouraging results as well.
Not only is the algorithm $100\%$ successful, on the test dataset of $4425$
schematics, with $10$ runs carried out on each schematic, the algorithm succeeded
$98.6\%$ of the time without having to put down forced wires. The algorithm was
required to put down more than $2$ forced wires only $0.1\%$ of the time.
From Figure
\ref{fig:final_time_trend} we see that as the circuit gets more complex, the
amount of time the algorithm takes sharply increases. This is due to a more
difficult placement task (especially as we have more op-amps) as well as a more
difficult wiring task. An important aspect of this Figure is that the maximum
point on the plot occurs at less than $180$ seconds. This indicates that on the
test dataset, the algorithm took at most about $3$ minutes to run. This is
encouraging from a practical stand point because $3$ minutes is not terribly long
for a student to have to wait for a layout to be generated.
Finally Figure \ref{fig:final_quality_trend} presents trends of quality as a
function of circuit complexity. Most importantly, we observe that the average
number of wire crosses never exceeds $1$.

\section{Further Work}

\subsection{Treating Resistors as Wires}

Our current solution treats resistors as one of the circuit components that we
work with. However, resistors have the special property among the components that
they look exactly like wires of length $3$.
In fact, the length need not even be specified.
We can think of resistors as wires of a fixed range of lengths. So one idea we
may attempt is to treat resistors in the wiring step of the algorithm instead of
the placement step. The search that we do in the wiring step would now need to be
more elaborate. Not only do we need to keep track of pairs of locations on the
protoboard that need to be connected, but we also need to know whether to put
a resistor between the two locations. In the latter case, we essentially have the
restriction that one of the wires we use to connect the pair of locations needs
to be of a length that can fit a resistor.

While this idea appears very promising, there are a few difficulties we may face
in implementing it. First, if there is any node in our circuit that is only
connected to resistors (and no other circuit components), then that node will be
unrepresented on the protoboard at the end of the placement step. One rather
unsatisfying solution to this problem may be reserving an empty column on the
protoboard for the node that we can use in the wiring step. A better solution may
be discovering the best places for the node as we are placing down resistors in
the wiring step, but this solution would certainly make the search we carry out
more complicated. Second, we will need a new kind of heuristic for our $A*$
search that takes resistors into account. The first idea that comes to mind may
be highly penalizing an absent resistor. Even with an amended heuristic, there
are cases we can imagine where the search may have a difficult time getting an
answer, for instance a pair of locations that are right next to each other that
must be connected by a resistor.

\subsection{Building Layouts Similar to Previously Generated Layouts}

One of the weaknesses of our tool is that it may generate different layouts for
the same circuit schematic. This is not a result of an explicit randomization
in our algorithm, but rather a side effect of some data structures we use such
as Python sets and dictionaries. A similar problem is that a slight change in
the circuit schematic may result in a completely different layout. It is,
therefore, very important that students in 6.01 be confident that they designed
the right circuit before taking the time to build their circuit.
This is where the simulation
capabilities of our tool come in to play. As an alternative solution to this
problem, it may be very useful to have our
tool remember the last placement it used and try to produce a new placement as
similar to the last one as possible in the case that the circuit was not
dramatically changed between requests for a layout.

\section{Remarks}

The results we have gotten for the final algorithm are indeed very encouraging.
It has a $100\%$ success rate and produces layouts that, by our metric, are very
good. The data we have collected suggests that we can put the tool in front of
students, and let them never worry about layout and only worry about circuit
design. If this tool saves $1$ lab hour per student per semester (time the
student would have spent producing layouts), then we are
looking at a savings of about $200$ 6.01 lab hours per semester, which is
fantastic success.
